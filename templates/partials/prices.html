{% set entries = vm.entries %}
{% set max_total = vm.maxTotal %}
{% set chart_date = request.query_params.get('date', 'today') %}
{% set chart_id = 'googleChart_' ~ chart_date %}
{% set date_string_id = 'dateString_' ~ chart_date %}
<section id="{{ chart_date }}Chart" class="chart" aria-label="Prices chart" data-date="{{ chart_date }}" data-margin="{{ request.query_params.get('margin', '0') }}">
  <div class="chart-head">
    {{ chart_date|title }}
    <span class="date-string" id="{{ date_string_id }}"></span>
  </div>
  <div class="chart-body">
    <div id="{{ chart_id }}" style="width: 100%; height: 100%;"></div>
  </div>
</section>

<script>
// Create chart for {{ chart_date }}
window.createChart_{{ chart_date }} = function() {
  const date = '{{ chart_date }}';
  const margin = '{{ request.query_params.get('margin', '0') }}';
  const chartElement = document.getElementById('{{ chart_id }}');
  const dateStringEl = document.getElementById('{{ date_string_id }}');
  
  if (!chartElement) {
    console.error('Chart element not found:', '{{ chart_id }}');
    return;
  }
  
  // Check if we already have cached data and chart instance for this element
  if (chartElement._chartInstance && chartElement._chartData && chartElement._originalPriceRange) {
    console.log('Redrawing existing chart for {{ chart_date }} without fetching new data');
    
    // Recalculate responsive options since viewport may have changed
    const isMobile = window.innerWidth <= 900;
    const isTablet = window.innerWidth > 900 && window.innerWidth <= 1200;
    const options = {
      title: '',
      hAxis: {
        title: '',
        textStyle: {
          fontSize: isMobile ? 10 : 12,
          color: 'white'
        },
        titleTextStyle: {
          color: 'white',
          fontSize: isMobile ? 10 : 12
        },
        slantedText: false,
        showTextEvery: 1,
        format: 'none',
        gridlines: { count: -1 },
        ticks: (() => {
          const hourTicks = [];
          for (let hour = 0; hour < 24; hour++) {
            hourTicks.push({v: hour.toString(), f: hour.toString()});
          }
          return hourTicks;
        })(),
        minTextSpacing: isTablet ? 25 : (isMobile ? 0 : 15),
        maxTextLines: 1,
        allowContainerBoundaryTextCutoff: false
      },
      vAxis: {
        title: '',
        minValue: chartElement._originalPriceRange.minPrice,
        maxValue: chartElement._originalPriceRange.maxPrice,
        viewWindow: {
          min: chartElement._originalPriceRange.minPrice,
          max: chartElement._originalPriceRange.maxPrice
        },
        ticks: (() => {
          const ticks = [];
          const maxValue = chartElement._originalPriceRange.maxPrice;
          for (let i = chartElement._originalPriceRange.minPrice; i <= maxValue; i += 1) {
            if (i % 5 === 0) {
              ticks.push({v: i, f: i.toString()});
            } else {
              ticks.push({v: i, f: ''});
            }
          }
          return ticks;
        })(),
        gridlines: {
          count: 0, // Disable automatic gridlines completely - use only custom ones
          color: 'transparent'
        },
        minorGridlines: {
          count: 0 // Disable minor gridlines between major ones
        },
        textStyle: {
          fontSize: isMobile ? 12 : 12, // Increase mobile font size for better visibility
          color: 'white'
        },
        titleTextStyle: {
          color: 'white',
          fontSize: isMobile ? 12 : 12
        }
      },
      isStacked: true,
      backgroundColor: 'black',
      width: '100%',
      height: '100%',
                chartArea: { 
            width: isMobile ? '75%' : '90%', // Reduce width to make room for Y-axis labels
            height: isMobile ? '85%' : (isTablet ? '50%' : '65%'),  // Much more conservative height for tablets to accommodate x-axis
            top: isMobile ? 5 : 15,
            left: isMobile ? 35 : 50, // Increase left margin for Y-axis labels on mobile
            right: isMobile ? 10 : 5,
            bottom: isMobile ? 15 : (isTablet ? 100 : 60)  // Much more space for X-axis labels on tablets
          },
      series: {
        0: { color: '#2ecc71' }, // Green
        1: { color: '#f1c40f' }, // Yellow  
        2: { color: '#e74c3c' }, // Red
        3: { color: '#666666' }  // Gray for margin
      },
      tooltip: {
        isHtml: true,
        textStyle: { 
          fontSize: isMobile ? 12 : 14,
          color: 'black'
        }
      }
    };
    
    chartElement._chartInstance.draw(chartElement._chartData, options);
    
    // Re-add major gridlines and now line after redraw
    setTimeout(() => {
      // Draw major gridlines (every 5 cents)
      drawMajorGridlines(chartElement._chartInstance, chartElement, chartElement._originalPriceRange.minPrice, chartElement._originalPriceRange.maxPrice);
      
      // Add now line for today's chart
      if (date === 'today' && chartElement._validData) {
        addNowLine(chartElement._chartInstance, chartElement, chartElement._validData);
      }
    }, 100);
    
    return;
  }
  
  console.log('Creating chart for:', date, 'margin:', margin);
  
  function drawChart() {
    // Convert date to proper format for API
    // Let the server handle timezone conversion - just send today/tomorrow as strings
    let dateStr;
    if (date === 'today') {
      dateStr = 'today';
      console.log('Today chart requesting: today');
    } else if (date === 'tomorrow') {
      dateStr = 'tomorrow';
      console.log('Tomorrow chart requesting: tomorrow');
    } else {
      dateStr = date;
    }
    
    fetch(`/api/chart-data?date_str=${dateStr}&margin=${margin}`)
      .then(response => response.json())
      .then(data => {
        console.log('Chart data received for', date, ':', data);
        
        // Track when this chart's data was fetched with metadata
        const fetchTime = Date.now();
        const fetchDate = new Date(fetchTime);
        
        if (window.chartDataTimestamps) {
          window.chartDataTimestamps[date] = fetchTime;
          console.log(`Updated ${date} chart data timestamp:`, fetchDate.toLocaleTimeString());
        }
        
        if (window.chartDataMetadata) {
          window.chartDataMetadata[date] = {
            fetchedDate: fetchDate.toDateString(),
            fetchedHour: fetchDate.getHours()
          };
          console.log(`Updated ${date} chart metadata:`, window.chartDataMetadata[date]);
        }
        console.log('Y-axis range:', data.minPrice, 'to', data.maxPrice);
        console.log('First few data rows:', data.data.slice(0, 3));
        console.log('Viewport width:', window.innerWidth, 'isMobile:', window.innerWidth <= 768);
        
        // Update date string
        if (dateStringEl) {
          dateStringEl.textContent = ` - ${data.dateString}`;
        }
        
        // Handle case where no data is available
        if (!data.data || data.data.length === 0) {
          chartElement.innerHTML = '<div style="color: white; padding: 20px; text-align: center;">No data available for this date</div>';
          return;
        }
        
        // Create Google Charts data table
        const chartData = new google.visualization.DataTable();
        chartData.addColumn('string', 'Time');
        chartData.addColumn('number', 'Low Price');
        chartData.addColumn({type: 'string', role: 'tooltip', p: {html: true}}); // Tooltip for Low Price
        chartData.addColumn('number', 'Medium Price');
        chartData.addColumn({type: 'string', role: 'tooltip', p: {html: true}}); // Tooltip for Medium Price
        chartData.addColumn('number', 'High Price');
        chartData.addColumn({type: 'string', role: 'tooltip', p: {html: true}}); // Tooltip for High Price
        chartData.addColumn('number', 'Margin');
        chartData.addColumn({type: 'string', role: 'tooltip', p: {html: true}}); // Tooltip for Margin
        
        // Validate data before adding rows and add custom tooltips
        const validData = data.data.filter(row => Array.isArray(row) && row.length === 5);
        if (validData.length === 0) {
          chartElement.innerHTML = '<div style="color: white; padding: 20px; text-align: center;">Invalid data format received</div>';
          return;
        }
        
        // Process data to add custom tooltips for each series
        const processedData = validData.map(row => {
          const [hourStr, lowPrice, mediumPrice, highPrice, marginPrice] = row;
          
          // Calculate total spot price (sum of low + medium + high)
          const spotPrice = (lowPrice || 0) + (mediumPrice || 0) + (highPrice || 0);
          const totalPrice = spotPrice + (marginPrice || 0);
          
          // Format time as HH:MM
          const hour = parseInt(hourStr);
          const timeFormatted = `${hour.toString().padStart(2, '0')}:00`;
          
          // Create a comprehensive tooltip that shows all components
          const createTooltip = () => {
            let tooltipContent = `
              <div style="padding: 8px; font-family: Arial, sans-serif; font-size: 13px; line-height: 1.4;">
                <div style="font-weight: bold; margin-bottom: 4px; color: #333;">${timeFormatted}</div>
            `;
            
            // Add each price component if it has a value (including negative values)
            if (lowPrice !== 0 && lowPrice !== null && lowPrice !== undefined) {
              tooltipContent += `<div style="color: #666;">Price: <strong>${lowPrice.toFixed(2)} c/kWh</strong></div>`;
            }
            if (mediumPrice !== 0 && mediumPrice !== null && mediumPrice !== undefined) {
              tooltipContent += `<div style="color: #666;">Price: <strong>${mediumPrice.toFixed(2)} c/kWh</strong></div>`;
            }
            if (highPrice !== 0 && highPrice !== null && highPrice !== undefined) {
              tooltipContent += `<div style="color: #666;">Price: <strong>${highPrice.toFixed(2)} c/kWh</strong></div>`;
            }
            
            // Always show margin
            tooltipContent += `<div style="color: #666;">Margin: <strong>${(marginPrice || 0).toFixed(2)} c/kWh</strong></div>`;
            
            // Add total with separator
            tooltipContent += `
                <div style="border-top: 1px solid #ddd; margin-top: 4px; padding-top: 4px; color: #333;">
                  <strong>Total: ${totalPrice.toFixed(2)} c/kWh</strong>
                </div>
              </div>
            `;
            
            return tooltipContent.trim();
          };
          
          const tooltip = createTooltip();
          
          // Return row with tooltip for each series: 
          // [Time, LowPrice, LowTooltip, MediumPrice, MediumTooltip, HighPrice, HighTooltip, Margin, MarginTooltip]
          // Use null instead of 0 to make Google Charts skip zero segments entirely
          // Note: Prices can be negative, so only null out if exactly zero
          return [
            hourStr,
            lowPrice !== 0 ? lowPrice : null, tooltip,        // Low price + tooltip (null only if exactly zero)
            mediumPrice !== 0 ? mediumPrice : null, tooltip,  // Medium price + tooltip (null only if exactly zero)
            highPrice !== 0 ? highPrice : null, tooltip,      // High price + tooltip (null only if exactly zero)
            marginPrice !== 0 ? marginPrice : null, tooltip   // Margin + tooltip (null only if exactly zero)
          ];
        });
        
        chartData.addRows(processedData);
        
        // Responsive chart options based on viewport width
        const isMobile = window.innerWidth <= 900;
        const isTablet = window.innerWidth > 900 && window.innerWidth <= 1200;
        // Everything above 900px uses the same side-by-side layout
        
        const options = {
          title: '',
          hAxis: {
            title: '',  // Remove axis title to save space
            textStyle: {
              fontSize: isMobile ? 10 : 12,
              color: 'white'
            },
            titleTextStyle: {
              color: 'white',
              fontSize: isMobile ? 10 : 12
            },
            slantedText: false,
            showTextEvery: 1,
            format: 'none',
            gridlines: {
              count: -1
            },
            // Explicitly define ticks to force labels
            ticks: (() => {
              const hourTicks = [];
              for (let hour = 0; hour < 24; hour++) {
                hourTicks.push({v: hour.toString(), f: hour.toString()});
              }
              return hourTicks;
            })(),
            // Force labels to be visible with proper spacing for tablets
            minTextSpacing: isTablet ? 25 : (isMobile ? 0 : 15),
            maxTextLines: 1,
            allowContainerBoundaryTextCutoff: false
          },
          vAxis: {
            title: '',  // Remove Y-axis title completely to save space
            minValue: data.minPrice,
            maxValue: Math.max(15, data.maxPrice),  // Ensure minimum of 15 cents
            viewWindow: {
              min: data.minPrice,
              max: Math.max(15, data.maxPrice)      // Ensure minimum of 15 cents
            },
            ticks: (() => {
              const ticks = [];
              const maxValue = Math.max(15, data.maxPrice);  // Use the same enforced maximum
              // Add all ticks (1-cent intervals) with custom formatting
              for (let i = data.minPrice; i <= maxValue; i += 1) {
                if (i % 5 === 0) {
                  // Major tick - show number label
                  ticks.push({v: i, f: i.toString()});
                } else {
                  // Minor tick - no label (empty string)
                  ticks.push({v: i, f: ''});
                }
              }
              return ticks;
            })(),
            gridlines: {
              count: 0, // Disable automatic gridlines completely - use only custom ones
              color: 'transparent'
            },
            minorGridlines: {
              count: 0 // Disable minor gridlines
            },
            textStyle: {
              fontSize: isMobile ? 12 : 12, // Increase mobile font size for better visibility
              color: 'white'
            },
            titleTextStyle: {
              color: 'white',
              fontSize: isMobile ? 12 : 12
            }
          },
          isStacked: true,
          legend: 'none',
          width: '100%',
          height: '100%',
          chartArea: { 
            width: isMobile ? '75%' : '90%', // Reduce width to make room for Y-axis labels
            height: isMobile ? '85%' : (isTablet ? '50%' : '65%'),  // Much more conservative height for tablets to accommodate x-axis
            top: isMobile ? 5 : 15,
            left: isMobile ? 35 : 50, // Increase left margin for Y-axis labels on mobile
            right: isMobile ? 10 : 5,
            bottom: isMobile ? 15 : (isTablet ? 100 : 60)  // Much more space for X-axis labels on tablets
          },
          backgroundColor: 'black',
          series: {
            0: { color: '#2ecc71' },  // green for low prices
            1: { color: '#f1c40f' },  // yellow for medium prices
            2: { color: '#e74c3c' },  // red for high prices
            3: { color: '#666666' }   // gray for margin
          },
          bar: {
            groupWidth: '70%'
          },
          tooltip: {
            isHtml: true,
            textStyle: { 
              fontSize: isMobile ? 12 : 14,
              color: 'black'
            }
          }
        };
        
        try {
          const chart = new google.visualization.ColumnChart(chartElement);
          
          // Cache chart instance, data, and price range for future redraws
          chartElement._chartInstance = chart;
          chartElement._chartData = chartData;
          chartElement._validData = validData; // Store for now line redrawing
          chartElement._originalPriceRange = {
            minPrice: data.minPrice,
            maxPrice: data.maxPrice
          };
          
          // Add ready event listener to draw major gridlines and today's "now" line
          google.visualization.events.addListener(chart, 'ready', function() {
            // Draw major gridlines (every 5 cents) - brighter than minor ones
            drawMajorGridlines(chart, chartElement, data.minPrice, data.maxPrice);
            
            if (date === 'today') {
              addNowLine(chart, chartElement, validData);
              // Set up timer to update the now line every minute
              startNowLineTimer(chart, chartElement, validData);
            }
          });
          
          chart.draw(chartData, options);
          console.log('Chart created and cached for future redraws');
        } catch (error) {
          console.error('Error creating or drawing chart:', error);
          chartElement.innerHTML = '<div style="color: white; padding: 20px;">Error creating chart: ' + error.message + '</div>';
        }
      })
      .catch(error => {
        console.error('Error fetching chart data:', error);
        chartElement.innerHTML = '<div style="color: white; padding: 20px;">Error loading chart data</div>';
      });
  }
  
  function startNowLineTimer(chart, chartElement, validData) {
    // Update the now line every minute
    const timer = setInterval(() => {
      updateNowLine(chart, chartElement, validData);
    }, 60000); // 60 seconds
    
    // Store timer reference for cleanup
    chartElement._nowLineTimer = timer;
    
    // Add visibility change listener to update now line when tab becomes visible
    const visibilityHandler = () => {
      if (!document.hidden) {
        console.log('Tab became visible - updating now line immediately');
        updateNowLine(chart, chartElement, validData);
      }
    };
    
    // Store handler reference for cleanup
    chartElement._visibilityHandler = visibilityHandler;
    document.addEventListener('visibilitychange', visibilityHandler);
  }

  function updateNowLine(chart, chartElement, validData) {
    try {
      // Only update if the document is visible (window is in foreground)
      if (document.hidden) {
        console.log('Skipping now line update - document is hidden');
        return;
      }
      
      // Remove existing now lines
      const existingLines = chartElement.querySelectorAll('.now-line');
      existingLines.forEach(line => line.remove());
      
      // Add new now line at current position
      addNowLineInternal(chart, chartElement, validData);
    } catch (error) {
      console.error('Error updating now line:', error);
    }
  }

  function drawMajorGridlines(chart, chartElement, minPrice, maxPrice) {
    try {
      console.log('drawMajorGridlines called with:', minPrice, 'to', maxPrice);
      
      // Remove any existing custom gridlines to prevent duplicates
      const existingLines = chartElement.querySelectorAll('.major-gridline, .minor-gridline, .custom-gridlines-group');
      existingLines.forEach(line => line.remove());
      
      const svgElement = chartElement.querySelector('svg');
      if (!svgElement) {
        console.error('No SVG element found in chart');
        return;
      }
      
      const chartLayout = chart.getChartLayoutInterface();
      const chartArea = chartLayout.getChartAreaBoundingBox();
      if (!chartArea) {
        console.error('No chart area bounding box found');
        return;
      }
      

      
      // Create a group element for all gridlines to ensure proper z-order
      const gridlinesGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      gridlinesGroup.setAttribute('class', 'custom-gridlines-group');
      
      // Draw all gridlines (1-cent intervals)
      let majorCount = 0;
      let minorCount = 0;
      

      
      for (let price = minPrice; price <= maxPrice; price += 1) {
        try {
          const yPosition = chartLayout.getYLocation(price);
          const isMajor = price % 5 === 0;
          
          // Create horizontal line
          const gridLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          gridLine.setAttribute('class', isMajor ? 'major-gridline' : 'minor-gridline');
          gridLine.setAttribute('x1', chartArea.left.toString());
          gridLine.setAttribute('y1', yPosition.toString());
          gridLine.setAttribute('x2', (chartArea.left + chartArea.width).toString());
          gridLine.setAttribute('y2', yPosition.toString());
          
          if (isMajor) {
            // Major gridlines - thick and bright to avoid anti-aliasing
            gridLine.setAttribute('stroke', '#aaaaaa');  // Bright gray for good visibility
            gridLine.setAttribute('stroke-width', '2');  // Thick enough to avoid anti-aliasing
            gridLine.setAttribute('opacity', '1.0');  // Full opacity
            gridLine.setAttribute('style', 'stroke: #aaaaaa !important; stroke-width: 2px !important; opacity: 1.0 !important;');
            gridLine.setAttribute('data-price', price.toString());  // Add data attribute for debugging

          } else {
            // Minor gridlines - thick enough to be consistent
            gridLine.setAttribute('stroke', '#666666');  // Medium gray
            gridLine.setAttribute('stroke-width', '1.5');  // Thick enough to avoid anti-aliasing
            gridLine.setAttribute('opacity', '0.7');  // Good opacity
            gridLine.setAttribute('style', 'stroke: #666666 !important; stroke-width: 1.5px !important; opacity: 0.7 !important;');

          }
          
          // Add gridline to the group
          gridlinesGroup.appendChild(gridLine);
          
          if (isMajor) majorCount++;
          else minorCount++;
        } catch (e) {
          // Skip if getYLocation fails for this price
          console.warn('Could not draw gridline for price:', price, e);
        }
      }
      

      
      // Insert gridlines before data bars but after background
      // Find the first data element (usually a 'g' group containing bars)
      const dataGroups = svgElement.querySelectorAll('g');
      let dataGroup = null;
      
      // Look for a group that contains rect elements (the chart bars)
      for (let group of dataGroups) {
        if (group.querySelector('rect')) {
          dataGroup = group;
          break;
        }
      }
      
      if (dataGroup) {
        svgElement.insertBefore(gridlinesGroup, dataGroup);

      } else {
        // Fallback: insert at the beginning but after defs
        let insertPoint = svgElement.firstChild;
        while (insertPoint && (insertPoint.tagName === 'defs' || insertPoint.tagName === 'rect')) {
          insertPoint = insertPoint.nextSibling;
        }
        
        if (insertPoint) {
          svgElement.insertBefore(gridlinesGroup, insertPoint);

        } else {
          svgElement.appendChild(gridlinesGroup);

        }
      }
      

    } catch (error) {
      console.error('Error drawing gridlines:', error);
    }
  }

  function addNowLine(chart, chartElement, validData) {
    // Initial draw - just call the internal function
    addNowLineInternal(chart, chartElement, validData);
  }

  function addNowLineInternal(chart, chartElement, validData) {
    try {
      // Remove any existing now lines to prevent duplicates
      const existingLines = chartElement.querySelectorAll('.now-line');
      existingLines.forEach(line => line.remove());
      
      // Get current time
      const now = new Date();
      const currentHour = now.getHours();
      const currentMinutes = now.getMinutes();
      
      // Find the SVG element in the chart
      const svgElement = chartElement.querySelector('svg');
      if (!svgElement) return;
      
      // Use Google Charts' getChartLayoutInterface to get precise positioning
      const chartLayout = chart.getChartLayoutInterface();
      const chartArea = chartLayout.getChartAreaBoundingBox();
      
      if (!chartArea) {
        console.warn('Could not get chart area bounding box');
        return;
      }
      
      // Find the data point index for the current hour
      const currentHourStr = currentHour.toString();
      let dataPointIndex = validData.findIndex(row => row[0] === currentHourStr);
      
      let lineX;
      
      if (dataPointIndex >= 0) {
        // Try to get the exact position using the data point index
        try {
          // Get the center position of the column for the current hour
          lineX = chartLayout.getXLocation(dataPointIndex);
        } catch (e) {
          console.warn('getXLocation failed, using fallback calculation');
          // Fallback calculation accounting for 70% groupWidth (30% gaps)
          const totalColumns = validData.length;
          const groupWidth = 0.7; // matches chart options
          const effectiveWidth = chartArea.width * groupWidth;
          const gapWidth = chartArea.width * (1 - groupWidth);
          const columnWidth = effectiveWidth / totalColumns;
          const gapPerColumn = gapWidth / (totalColumns + 1);
          
          lineX = chartArea.left + gapPerColumn + (dataPointIndex * (columnWidth + gapPerColumn)) + (columnWidth / 2);
        }
      } else {
        // Hour not found in data, calculate position accounting for gaps and actual bar positions
        // Since we now pad data to 24 hours, this should rarely happen, but handle it properly
        const totalColumns = 24; // We always have 24 hours now
        const groupWidth = 0.7; // matches chart options
        const effectiveWidth = chartArea.width * groupWidth;
        const gapWidth = chartArea.width * (1 - groupWidth);
        const columnWidth = effectiveWidth / totalColumns;
        const gapPerColumn = gapWidth / (totalColumns + 1);
        
        // Position within the current hour based on minutes
        const exactPosition = currentHour + (currentMinutes / 60);
        const hourStart = chartArea.left + gapPerColumn + (currentHour * (columnWidth + gapPerColumn));
        const minuteOffset = (currentMinutes / 60) * columnWidth;
        
        lineX = hourStart + minuteOffset;
      }
      
      // Create yellow line
      const nowLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      nowLine.setAttribute('class', 'now-line');
      nowLine.setAttribute('x1', lineX.toString());
      nowLine.setAttribute('y1', chartArea.top.toString());
      nowLine.setAttribute('x2', lineX.toString());
      nowLine.setAttribute('y2', (chartArea.top + chartArea.height).toString());
      nowLine.setAttribute('stroke', '#ffcc00');
      nowLine.setAttribute('stroke-width', '4');
      nowLine.setAttribute('opacity', '0.8');
      
      svgElement.appendChild(nowLine);
      
      console.log('Now line positioned at hour', currentHour, 'data index', dataPointIndex, 'x-position', lineX);
    } catch (error) {
      console.error('Error adding now line:', error);
    }
  }
  
  // Initialize chart
  if (typeof google !== 'undefined' && google.charts) {
    google.charts.load('current', {packages: ['corechart']});
    google.charts.setOnLoadCallback(drawChart);
  } else {
    // If Google Charts isn't loaded yet, wait for it
    const checkGoogle = setInterval(() => {
      if (typeof google !== 'undefined' && google.charts) {
        clearInterval(checkGoogle);
        google.charts.load('current', {packages: ['corechart']});
        google.charts.setOnLoadCallback(drawChart);
      }
    }, 100);
  }
};

// Execute the chart creation function immediately
window.createChart_{{ chart_date }}();
</script>
