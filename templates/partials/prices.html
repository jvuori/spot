{% set entries = vm.entries %}
{% set max_total = vm.maxTotal %}
{% set chart_date = request.query_params.get('date', 'today') %}
{% set chart_id = 'googleChart_' ~ chart_date %}
{% set date_string_id = 'dateString_' ~ chart_date %}
<section class="chart" aria-label="Prices chart" data-date="{{ chart_date }}" data-margin="{{ request.query_params.get('margin', '0') }}">
  <div class="chart-head">
    {{ chart_date|title }}
    <span class="date-string" id="{{ date_string_id }}"></span>
  </div>
  <div class="chart-body">
    <div id="{{ chart_id }}" style="width: 100%; height: 100%;"></div>
  </div>
</section>

<script>
// Create chart for {{ chart_date }}
window.createChart_{{ chart_date }} = function() {
  const date = '{{ chart_date }}';
  const margin = '{{ request.query_params.get('margin', '0') }}';
  const chartElement = document.getElementById('{{ chart_id }}');
  const dateStringEl = document.getElementById('{{ date_string_id }}');
  
  if (!chartElement) {
    console.error('Chart element not found:', '{{ chart_id }}');
    return;
  }
  
  console.log('Creating chart for:', date, 'margin:', margin);
  
  function drawChart() {
    // Convert date to proper format for API
    // Let the server handle timezone conversion - just send today/tomorrow as strings
    let dateStr;
    if (date === 'today') {
      dateStr = 'today';
      console.log('Today chart requesting: today');
    } else if (date === 'tomorrow') {
      dateStr = 'tomorrow';
      console.log('Tomorrow chart requesting: tomorrow');
    } else {
      dateStr = date;
    }
    
    fetch(`/api/chart-data?date_str=${dateStr}&margin=${margin}`)
      .then(response => response.json())
      .then(data => {
        console.log('Chart data received for', date, ':', data);
        console.log('Y-axis range:', data.minPrice, 'to', data.maxPrice);
        
        // Update date string
        if (dateStringEl) {
          dateStringEl.textContent = ` - ${data.dateString}`;
        }
        
        // Handle case where no data is available
        if (!data.data || data.data.length === 0) {
          chartElement.innerHTML = '<div style="color: white; padding: 20px; text-align: center;">No data available for this date</div>';
          return;
        }
        
        // Create Google Charts data table
        const chartData = new google.visualization.DataTable();
        chartData.addColumn('string', 'Time');
        chartData.addColumn('number', 'Low Price');
        chartData.addColumn('number', 'Medium Price'); 
        chartData.addColumn('number', 'High Price');
        chartData.addColumn('number', 'Margin');
        
        // Validate data before adding rows
        const validData = data.data.filter(row => Array.isArray(row) && row.length === 5);
        if (validData.length === 0) {
          chartElement.innerHTML = '<div style="color: white; padding: 20px; text-align: center;">Invalid data format received</div>';
          return;
        }
        
        chartData.addRows(validData);
        
        // Chart options similar to Angular component
        const options = {
          title: '',
          hAxis: {
            title: 'Hour',
            textStyle: {
              fontSize: 12,
              color: 'white'
            },
            titleTextStyle: {
              color: 'white'
            }
          },
          vAxis: {
            title: 'Price (cnt/kWh)',
            minValue: data.minPrice,
            maxValue: data.maxPrice,
            viewWindow: {
              min: data.minPrice,
              max: data.maxPrice
            },
            ticks: (() => {
              const ticks = [];
              // Add all ticks (1-cent intervals) with custom formatting
              for (let i = data.minPrice; i <= data.maxPrice; i += 1) {
                if (i % 5 === 0) {
                  // Major tick - show label
                  ticks.push({v: i, f: i.toString()});
                } else {
                  // Minor tick - no label (empty string)
                  ticks.push({v: i, f: ''});
                }
              }
              return ticks;
            })(),
            gridlines: {
              color: '#444444',  // Darker for minor lines
              count: -1  // Use all our custom ticks
            },
            // Add major gridlines on top
            minorGridlines: {
              count: 0  // Disable automatic minor gridlines
            },
            textStyle: {
              fontSize: 12,
              color: 'white'
            },
            titleTextStyle: {
              color: 'white'
            }
          },
          isStacked: true,
          legend: 'none',
          width: '100%',
          height: '100%',
          chartArea: { 
            width: '90%', 
            height: '85%',
            top: 15,
            left: 50
          },
          backgroundColor: 'black',
          series: {
            0: { color: '#2ecc71' },  // green for low prices
            1: { color: '#f1c40f' },  // yellow for medium prices  
            2: { color: '#e74c3c' },  // red for high prices
            3: { color: '#666666' }   // gray for margin
          },
          bar: {
            groupWidth: '70%'
          },
          tooltip: {
            textStyle: { 
              fontSize: 14,
              color: 'black'
            }
          }
        };
        
        const chart = new google.visualization.ColumnChart(chartElement);
        
        // Add ready event listener to draw yellow "now" line for today and enhance gridlines
        google.visualization.events.addListener(chart, 'ready', function() {
          // Draw enhanced major gridlines (every 5 cents)
          drawMajorGridlines(chart, chartElement, data.minPrice, data.maxPrice);
          
          if (date === 'today') {
            addNowLine(chart, chartElement, validData);
            // Set up timer to update the now line every minute
            startNowLineTimer(chart, chartElement, validData);
          }
        });
        
        chart.draw(chartData, options);
      })
      .catch(error => {
        console.error('Error fetching chart data:', error);
        chartElement.innerHTML = '<div style="color: white; padding: 20px;">Error loading chart data</div>';
      });
  }
  
  function startNowLineTimer(chart, chartElement, validData) {
    // Update the now line every minute
    const timer = setInterval(() => {
      updateNowLine(chart, chartElement, validData);
    }, 60000); // 60 seconds
    
    // Store timer reference for cleanup
    chartElement._nowLineTimer = timer;
  }

  function updateNowLine(chart, chartElement, validData) {
    try {
      // Only update if the document is visible (window is in foreground)
      if (document.hidden) {
        console.log('Skipping now line update - document is hidden');
        return;
      }
      
      // Remove existing now lines
      const existingLines = chartElement.querySelectorAll('.now-line');
      existingLines.forEach(line => line.remove());
      
      // Add new now line at current position
      addNowLineInternal(chart, chartElement, validData);
    } catch (error) {
      console.error('Error updating now line:', error);
    }
  }

  function addNowLine(chart, chartElement, validData) {
    // Initial draw - just call the internal function
    addNowLineInternal(chart, chartElement, validData);
  }

  function drawMajorGridlines(chart, chartElement, minPrice, maxPrice) {
    try {
      const svgElement = chartElement.querySelector('svg');
      if (!svgElement) return;
      
      const chartLayout = chart.getChartLayoutInterface();
      const chartArea = chartLayout.getChartAreaBoundingBox();
      if (!chartArea) return;
      
      // Draw brighter lines at 5-cent intervals
      for (let price = minPrice; price <= maxPrice; price += 5) {
        try {
          const yPosition = chartLayout.getYLocation(price);
          
          // Create horizontal line for major gridline
          const majorLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          majorLine.setAttribute('class', 'major-gridline');
          majorLine.setAttribute('x1', chartArea.left.toString());
          majorLine.setAttribute('y1', yPosition.toString());
          majorLine.setAttribute('x2', (chartArea.left + chartArea.width).toString());
          majorLine.setAttribute('y2', yPosition.toString());
          majorLine.setAttribute('stroke', '#999999');  // Even brighter than before
          majorLine.setAttribute('stroke-width', '1');
          majorLine.setAttribute('opacity', '0.9');
          
          svgElement.appendChild(majorLine);
        } catch (e) {
          // Skip if getYLocation fails for this price
          console.warn('Could not draw major gridline for price:', price);
        }
      }
    } catch (error) {
      console.error('Error drawing major gridlines:', error);
    }
  }

  function addNowLineInternal(chart, chartElement, validData) {
    try {
      // Remove any existing now lines to prevent duplicates
      const existingLines = chartElement.querySelectorAll('.now-line');
      existingLines.forEach(line => line.remove());
      
      // Get current time
      const now = new Date();
      const currentHour = now.getHours();
      const currentMinutes = now.getMinutes();
      
      // Find the SVG element in the chart
      const svgElement = chartElement.querySelector('svg');
      if (!svgElement) return;
      
      // Use Google Charts' getChartLayoutInterface to get precise positioning
      const chartLayout = chart.getChartLayoutInterface();
      const chartArea = chartLayout.getChartAreaBoundingBox();
      
      if (!chartArea) {
        console.warn('Could not get chart area bounding box');
        return;
      }
      
      // Find the data point index for the current hour
      const currentHourStr = currentHour.toString();
      let dataPointIndex = validData.findIndex(row => row[0] === currentHourStr);
      
      let lineX;
      
      if (dataPointIndex >= 0) {
        // Try to get the exact position using the data point index
        try {
          // Get the center position of the column for the current hour
          lineX = chartLayout.getXLocation(dataPointIndex);
        } catch (e) {
          console.warn('getXLocation failed, using fallback calculation');
          // Fallback calculation accounting for 70% groupWidth (30% gaps)
          const totalColumns = validData.length;
          const groupWidth = 0.7; // matches chart options
          const effectiveWidth = chartArea.width * groupWidth;
          const gapWidth = chartArea.width * (1 - groupWidth);
          const columnWidth = effectiveWidth / totalColumns;
          const gapPerColumn = gapWidth / (totalColumns + 1);
          
          lineX = chartArea.left + gapPerColumn + (dataPointIndex * (columnWidth + gapPerColumn)) + (columnWidth / 2);
        }
      } else {
        // Hour not found in data, calculate position accounting for gaps and actual bar positions
        // Since we now pad data to 24 hours, this should rarely happen, but handle it properly
        const totalColumns = 24; // We always have 24 hours now
        const groupWidth = 0.7; // matches chart options
        const effectiveWidth = chartArea.width * groupWidth;
        const gapWidth = chartArea.width * (1 - groupWidth);
        const columnWidth = effectiveWidth / totalColumns;
        const gapPerColumn = gapWidth / (totalColumns + 1);
        
        // Position within the current hour based on minutes
        const exactPosition = currentHour + (currentMinutes / 60);
        const hourStart = chartArea.left + gapPerColumn + (currentHour * (columnWidth + gapPerColumn));
        const minuteOffset = (currentMinutes / 60) * columnWidth;
        
        lineX = hourStart + minuteOffset;
      }
      
      // Create yellow line
      const nowLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      nowLine.setAttribute('class', 'now-line');
      nowLine.setAttribute('x1', lineX.toString());
      nowLine.setAttribute('y1', chartArea.top.toString());
      nowLine.setAttribute('x2', lineX.toString());
      nowLine.setAttribute('y2', (chartArea.top + chartArea.height).toString());
      nowLine.setAttribute('stroke', '#ffcc00');
      nowLine.setAttribute('stroke-width', '4');
      nowLine.setAttribute('opacity', '0.8');
      
      svgElement.appendChild(nowLine);
      
      console.log('Now line positioned at hour', currentHour, 'data index', dataPointIndex, 'x-position', lineX);
    } catch (error) {
      console.error('Error adding now line:', error);
    }
  }
  
  // Initialize chart
  if (typeof google !== 'undefined' && google.charts) {
    google.charts.load('current', {packages: ['corechart']});
    google.charts.setOnLoadCallback(drawChart);
  } else {
    // If Google Charts isn't loaded yet, wait for it
    const checkGoogle = setInterval(() => {
      if (typeof google !== 'undefined' && google.charts) {
        clearInterval(checkGoogle);
        google.charts.load('current', {packages: ['corechart']});
        google.charts.setOnLoadCallback(drawChart);
      }
    }, 100);
  }
};

// Execute the chart creation function immediately
window.createChart_{{ chart_date }}();
</script>
